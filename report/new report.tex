\documentclass[11pt,a4paper]{scrartcl}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{array}

\usepackage{listings}
\usepackage{tikz}
\tikzset{main node/.style={circle,fill=blue!20,draw,minimum size=1cm,inner sep=0pt},
}

\usepackage{hyperref}

\addtokomafont{disposition}{\rmfamily}




\title{MSc, MEng and MMath Examinations, 2017?18
	DEPARTMENT OF COMPUTER SCIENCE
	Model-Driven Engineering (MODE)
	Open Individual Assessment}
\date{}

\begin{document}
	%-----------------------------------------------------
	% Title Page
	%-----------------------------------------------------
	
	\begin{titlepage}
		\begin{center}
			
			\large
			\textbf{University of York} \\
			\vspace{0.2cm}
			\textbf{MSc, MEng and MMath Examinations, 2017-18} \\
			\vspace{0.2cm}
			\textbf{DEPARTMENT OF COMPUTER SCIENCE} \\
			
			\vspace{2cm}
			
			\huge
			\textbf{Model-Driven Engineering (MODE)} 
			\textbf{Open Individual Assessment} \\
			
			\vspace{2cm}
			
			\Large
			\textbf{Examination Number} \\
			\textbf{Y1403115}
			
		\end{center}
	\end{titlepage}
	
	


\section{Abstract Syntax and Constraints}
%Explain how you have arrived at the abstract
%syntax and any well-formedness constraints for your DSL, justify the decisions
%that you have made, and discuss how you have tested your abstract syntax and
%well-formedness constraints.

	\subsection{Problem analysis}
	A domain specific language(DSL) needs to be created which allows the creation, modification and modelling relationships between four entities - system requirements, customer requirements, team members and test cases. Possible relationships between two requirements can be decomposition(also referred to as dependency in this report) and conflict. Requirements can be assigned to team members and can also be verified by test cases. 
	The implementation of the metamodel in Emfatic defines 4 concrete classes for each of the entities mentioned above along with a container class RequirementsModel and a few abstract classes defined to limit duplication and enforce constraints.
	
	\begin{lstlisting}
	class RequirementsModel
	abstract class Identifiable
	abstract class Describable
	abstract class Requirement extends Identifiable, Describable
	class CustomerRequirement extends Requirement
	class SystemRequirement extends Requirement
	class TestCase extends Identifiable, Describable
	class TeamMember extends Identifiable
	\end{lstlisting}
	
	\subsection{Abstract classes}
	System requirements and customer requirements share a number of common properties. It is obvious that having a super class Requirement, which captures these common properties is beneficial and avoids duplication. All requirements have a progress attribute and an updateProgress operation which will be discussed later on.
	
	According to the specification, both requirements and test-cases need to have a description. This is a string attribute in terms of the Emfatic code. In order to avoid duplication by defining this attribute in both classes an abstract class Describable is used, which is a superclass of both requirements and test-cases. An additional constraint for requirement description is that they need to be at least 10 characters long. This is enforced via the EVL validation.
	
	Requirements also must have an unique identifier. While not specifically stated in the specification, being able to uniquely identify test-cases and team members is an important property of the DSL, as it avoids visual ambiguity for users. For this reason, the abstract class Identifiable is defined, which has a string attribute id, and is a super class of requirements, test-cases and team members. The uniqueness constraint is enforced by the EVL validation.
	
	\subsection{Requirement Decomposition}
	Requirements are the most important entities in the DSL. They form a directed acyclic graph structure of decomposition relationships. For simplicity a parent-child abstraction is used to model this relationship. That is requirements being decomposed are parents of requirements in the decomposition and the latter are children of the former. The decomposition relationships can be viewed as breaking down requirements into multiple smaller child requirements, which together form the parent requirement. This must be true because, according to the specification, parent requirement's progress is the average of it's children, which is 100\% when all of it's children are also 100\%. Further constraints on this realationship are:
	
	\begin{enumerate} \label{lst:constraints}
		\item Customer requirements can be decomposed into technical requirements, but not the other way round.
		\item Each customer requirement needs to be decomposed into at least one technical requirement.
		\item Each technical requirement needs originate from at least one customer requirement.
		\item Requirements decomposition must be free of cycles.
	\end{enumerate}
	
	This means that each path in the requirements graph (see \autoref{fig:graph}) must begin with 1 or more customer requirements followed by 1 or more system requirements. The metamodel defines a ref
	
	\begin{figure}[h!]
		
		\centering
	
		\begin{tikzpicture}
		
			\node (a) at (0,3)  {$CR_1$};
			\node (b) at (2,3)  {$CR_2$};
			\node (c) at (3,3)  {$\ldots$};
			\node (d) at (4,3)  {$CR_n$};
			
			\node (e) at (2,2)  {$CR_k^{*}$};
			
			\node (f) at (2,1)  {$SR_k^*$};
			
			\node (g) at (0,0)  {$SR_1$};
			\node (h) at (2,0)  {$SR_2$};
			\node (i) at (3,0)  {$\ldots$};
			\node (j) at (4,0)  {$SR_n$};
			
			\draw (a) edge[->] (e) 
			(a) edge[->] (e)
			(b) edge[->] (e)
			(d) edge[->] (e)
			(e) edge[->] (f)
			(f) edge[->] (g)
			(f) edge[->] (h)
			(f) edge[->] (j);
			
		\end{tikzpicture}
		
		\caption{Requirement graph structure}
		\label{fig:graph}
	\end{figure}	

	To model this relationship in the Emfatic code the Requirements superclass has a multivalued reference of type Requirement, for both the children and parents of the requirement. All of the constraints discussed above are handled by the model validation in EVL.
	
	An alternative solution is to have the children and parent references in the subclasses as shown on \autoref{fig:alt-req}. This way system requirements are restricted to have only system requirements as children. However an opposite for systemParents has to be both customerChildren and systemChildren, which is not possible in Ecore and being able to navigate from children to parents as well as the other way around is very important for the model management tasks. So this solution was ultimately discounted.
	
	\begin{figure}[h!]
	\centering
	\begin{lstlisting}
class CustomerRequirement extends Requirement{
	ref Requirement[*]#conflictsIncoming customerChildren;
	ref CustomerRequirement[*] customerParents;
}
	
class SystemRequirement extends Requirement{
	ref SystemRequirement[*]#systemParents systemChildren;
	ref Requirement[*] systemParents;
}
	\end{lstlisting}
	
	\caption{Alternative implementation of requirements decomposition.}
	\label{fig:alt-req}
	
	\end{figure}
	

	\subsection{Requirement Conflicts}
	Requirements can also be in conflict with each other, which means that only one of them can be completed. Conflicts are constrained to the same type of requirement - system requirements can be in conflict with system requirements only and customer requirements with customer requirements only. This constraint is directly enforced by the meta-model by having different types for the conflicts reference. It is also important to be able to navigate both ways of a conflict relation ship and this is why opposites are used as well. 
	
	Additional constraints on conflicts arise from the nature of requirement decomposition and progress and are defined in the EVL validation. It does not make sense for requirements to decompose into requirements, with which they are in conflict. Also the decompositions of two conflicting requirements must be two disjoint sets of requirements otherwise one of them would not be completable without the other. Even when having these constraints users are still able to mark two conflicting requirements as complete, which should not be possible. This is way an additional EVL constraint is defined which checks if two conflicting requirements are both complete.
	
	\subsection{Requirement Progress}
	All requirements have a progress field which is either set by the user, if the requirement doesn't have any children or is the average of it's children?s progress. An easy way to enforce this constraint on the progress field is to leave it to the user to calculate the progress of each requirement and just check weather or not the constraint is satisfied in the EVL validation. However this is very error prone and not user friendly. 
	
	In order to automate calculation of progress, the java code of the GMF editor had to be modified. In particular the RequirementImpl.java file which defines the implementation of requirement entities. An updateProgress method is defined which calculates progress of a requirement from the progress of it's children (taking the average). Whenever a requirement's progress is set by the user  updateProgress method on all of it's parents and whenever a requirement is assigned a new child it recalculates it's own progress again notifying parents of the change. Also whenever the progress of a parent requirement is set manually it automatically calculates the correct average progress of it's children and ignores the user defined progress. This is done using the notification mechanism of EMF - by adding an adapter to the requirement which listenes to SET notifiactions for progress and children fields. 
	
	The more commonly used derived attributes pattern could not be used, as progress is a derived attribute only if the requirement has children and is user defined if it does not. 
	
	An EVL constrained is used to check that progress is a valid percentage - between 0\% and 100\%
	
	\subsection{Team Members and Test Cases}
	Leaf requirements in the requirements decomposition graph make up all of the work needed to complete the whole graph, because if they are 100\% complete, then all of their parents are also 100\% complete. This means it only ever makes sense for team members to work on leaf requirements and for test cases to only verify leaf requirements. This is why EVL constraints defined for both test-cases and team members verify that only leaf requirements are assigned to any of them. 
	
	Altough, this approach complies with the assessment specification, assigning non-leaf requirements to team members and test cases could provide better user experience. For example if all the children of a particular requirement are assigned to a specific team member, then it would be safe to indicate this by assigning the parent requirement to the team member instead. This would limit the number of connections in the visual editor and avoid visual ambiguity. And the same applies to test-cases. However, due to timing constraints on the assessment, this was not implemented.
	
	Another important constraint for test-cases to note is that they can verify only system requirements and this is enforced by the meta-model.
	
	\subsection{EVL Constraints}
	All EVL constraints have a sensible error message for the user. All except for the constraint that checks for cycles in the decomposition graph and the one that checks for the length of requirement descriptions also define a quick fix. The two constraints that do not have quick fixes defined, do not have a simple solution - it doesn't make sense to automatically generate a description if it is not long enough and fixing cycles in a graph is not straightforward at all. 
	
	\subsection{Testing}
	
	

	\section{Editor}
	%Explain the editor for your DSL, justify the decisions that you have made,
	%and briefly argue why your editor provides an appropriate notation for your DSL.
	The editor for the DSL is an Eugenia generated GMF diagram editor. It uses a graph based diagram notation and it provides four types of nodes (objects) - CustomerRequirements, SystemRequirements, TeamMembers and TestCases. Each type of object has a different colour border in order to avoid visual ambiguity. All attributes of each object are editable from the text fields in the diagram.
	
	There are also different types of conncections between objects. The Dependency connection is an arrow, which indicates requirement decomposition relationship and the arrow points to the child requirement. System Requirement and Customer Requirement Conflicts are connections that indicate conflicts between the particular type of requirements and are represented by a dashed line with the same color as the requirement type. Verification and Assignment connections are used to relate requirements and team members and requirements and test-cases and have the same color as the particular object(team member or test-case).
	
	
	\subsection{Justification}
	The editor allows users to create and modify the fields of each type of the four main entities - system and customer requirements, test cases and team members. All references between the entities can be modelled using connections. And the color coding makes models much clearer and easier to understand.



\section{Model Management Operations}
%Explain the model management operations for
%your DSL, justify the decisions that you have made, and briefly demonstrate that
%the model management operations can be used to fulfill the model management
%tasks described in Section 1.	

	
\end{document}
